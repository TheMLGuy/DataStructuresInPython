'''
Created on Jul 7, 2017

@author: Ashwin
'''
#    https://gist.github.com/NahimNasser/4705371

class aboutTree(object):
    #defining methods to create a node with its data and left,right pointers; also methods
    #to interact with left/right pointers
    def __init__(self,data):
        self.data=data
        self.left=None
        self.right=None
    def getData(self):
        return self.data
    def getRight(self):
        return self.right
    def getLeft(self):
        return self.left
    def setData(self,data):
        self.data=data
    #def insertIntoBinaryTree(self,l):
        #'l' is a list of numbers which needs to be inserted into the tree
        # the property of balancing the binary tree needs to be handled
        #left subtree < root< right subtree    
        
    def insertIntoBinaryTree(self,dataToBeInserted):
        
        if self.data<dataToBeInserted:
            if self.right==None:
                self.right=aboutTree(dataToBeInserted)
            else:
                self.right.insertIntoBinaryTree(dataToBeInserted)
        else:
            if self.left==None:
                self.left=aboutTree(dataToBeInserted)
            else:
                self.left.insertIntoBinaryTree(dataToBeInserted)           
            
#root=aboutTree(5)
    def recursiveInorderTraversal(self,root):
        #this function gets the parent of the node described by data
        #traversedList=[]
        
        if not root:
            return
        node=root
        self.recursiveInorderTraversal(node.left)
        print(node.data)
        self.recursiveInorderTraversal(node.right)
        
    def nonRecursiveInorderTraversal(self,root):
        if not root:
            return
        stack=[]
        node=root
        temp=[]
        while stack or node:
            if node:
                stack.append(node)
                node=node.left
            else:
                node=stack.pop()
                temp.append(node.data)
                node=node.right    
        return temp    
                
    def recursivePreOrderTraversal(self,root):
        if not root:
            return
        node=root
        print(node.data)
        self.recursivePreOrderTraversal(node.left)
        self.recursivePreOrderTraversal(node.right)
        
    def nonRecursivePreOrderTraversal(self,root):
        if not root:
            return
        node=root
        stack=[]
        stack.append(root)
        result=[]
        while stack:
            node=stack.pop()
            result.append(node.data)
            if node.right: stack.append(node.right)
            if node.left: stack.append(node.left) 
        return result            
    def recursivePostOrderTraversal(self,root):
        node=root
        if not node:
            return
        self.recursivePostOrderTraversal(node.left)
        self.recursivePostOrderTraversal(node.right)
        print(node.data)
     
    def nonRecursivePostOrderTraversal(self):
        #2 stack approach
        if not root:
            return
        s1=[]
        s2=[]
        s1.append(root)
        while(s1!=[]):
            node=s1.pop()
            s2.append(node)
            if node.left!=None:
                s1.append(node.left)
            if node.right!=None:
                s1.append(node.right)
        while s2!=[]:
            node=s2.pop()
            print(node.data)             
    class queue(object):
        def __init__(self):
            self.items=[]
        def enque(self,item):
            self.items.insert(0,item)
        def deque(self):
            self.items.pop()
                    
    def levelOrderTraversal(self,root):
        #use queue to solve this problem
        #queueobj=queue()
        queue=[]
        if not root:
            return
        node=root
        queue.insert(0,node) 
        while queue!=[]:
            node=queue.pop()
            print(node.data)
            if node.left!=None:
                queue.insert(0,node.left)
            if node.right!=None:
                queue.insert(0,node.right)
            
    def maxElementInBinaryTree(self,root):
        if not root:
            return    
        while root.right!=None:
            root=root.right
        return root.data    
    def recursiveMaxElementInBinaryTree(self,root):
        if root==None:
            return -1
        elif root.right==None:
            return root.data
        return self.recursiveMaxElementInBinaryTree(root.right)
    
    def searchIterativeForData(self,root,data):
        if root==None:
            return False
        queue=[]
        node=root
        queue.insert(0, root)
        while queue!=[]:
            node=queue.pop()
            if node.data==data:
                
                return True
            if node.left!=None:
                queue.insert(0,node.left)
            if node.right!=None:
                queue.insert(0, node.right)
        return False            
                
    def searchRecursiveForData(self,root,data):    
        if root==None:
            return False
        elif root.data==data:
            return True
        else:
            if root.data>data:
                temp=self.searchRecursiveForData(root.left, data)
            else:
                temp=self.searchRecursiveForData(root.right, data)
            if temp==True:
                return True
            else: return False    
root=aboutTree(4)
root.insertIntoBinaryTree(5)
root.insertIntoBinaryTree(2)
root.insertIntoBinaryTree(1)
root.insertIntoBinaryTree(0)
root.insertIntoBinaryTree(7)
#print("Recursive Inorder Traversal\n*******************")
#print(root.recursiveInorderTraversal(root))       
#print("Non Recursive Inorder Traversal\n*******************")
#print(root.nonRecursiveInorderTraversal(root)) 
#print("Non Recursive Preorder Traversal\n*******************")
#print(root.nonRecursivePreOrderTraversal(root))
#print("Recursive Preorder Traversal\n*******************")
#print(root.recursivePreOrderTraversal(root))
#print("Recursive Postorder traversal\n**************")
#print(root.recursivePostOrderTraversal(root))
#print("Non recursive postorder traversal")
#print(root.nonRecursivePostOrderTraversal())
#print("level order traversal\n*********")
#print(root.levelOrderTraversal(root))
#print("Max element in tree\n**********")
#print(root.recursiveMaxElementInBinaryTree(root))
print("search using iterative method\n********")
print(root.searchRecursiveForData(root, 0))
